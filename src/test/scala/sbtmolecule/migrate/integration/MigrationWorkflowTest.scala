package sbtmolecule.migrate.integration

import molecule.base.metaModel.MetaDomain
import org.flywaydb.core.Flyway
import sbtmolecule.ParseAndGenerate
import sbtmolecule.migrate.BaseTest
import sbtmolecule.migration.{MigrationDetector, MigrationFileGenerator}
import utest.*

import java.sql.{Connection, DriverManager}

/**
 * Integration test that simulates the complete migration workflow with separate test steps.
 * Tests run sequentially and share state through a test fixture.
 *
 * Simulates a real user workflow:
 * 1. Start with Foo.scala containing Person with "name" attribute
 * 2. User modifies Foo.scala to have "fullName" instead (same file)
 * 3. Run sbt moleculeGen - detects ambiguous change
 * 4. Plugin generates Foo_migration.scala beside Foo.scala
 * 5. User edits Foo_migration.scala to resolve ambiguity
 * 6. Run sbt moleculeGen again - generates SQL migration
 * 7. Flyway executes migration
 * 8. Verify data persists with new schema
 */
object MigrationWorkflowTest extends BaseTest {

  // Shared state across tests
  var tempDir              : os.Path    = _
  var domainDir            : os.Path    = _
  var fooFile              : os.Path    = _
  var fooMigrationFile     : os.Path    = _
  var dbUrl                : String     = _
  var conn                 : Connection = _
  var initialMeta          : MetaDomain = _
  var modifiedMeta         : MetaDomain = _
  var resolvedMigrationMeta: MetaDomain = _
  var annotatedBefore      : MetaDomain = _

  override def tests: Tests = Tests {

    "1. Setup: Create Foo.scala and database with initial data" - {
      // Create test output directory in test source tree for easy inspection
      val projectRoot = os.pwd
      tempDir = projectRoot / "src" / "test" / "scala" / "sbtmolecule" / "migrate" / "integration" / "workflowTempFiles"

      // Clean and recreate
      if (os.exists(tempDir)) os.remove.all(tempDir)

      domainDir = tempDir / "step1_initial"
      os.makeDir.all(domainDir)

      // Create Foo.scala with Person entity having only "name" attribute
      fooFile = domainDir / "Foo.scala"
      os.write(fooFile,
        """package sbtmolecule.migrate.integration.workflowTempFiles.step1_initial
          |
          |import molecule.DomainStructure
          |
          |trait Foo extends DomainStructure {
          |  trait Person {
          |    val name = oneString
          |  }
          |}
          |""".stripMargin)

      // Parse initial structure (simulates first sbt moleculeGen)
      val List(meta) = ParseAndGenerate(fooFile.toString).generators.map(_.metaDomain)
      initialMeta = meta

      // Create Flyway V1 migration with initial schema
      val migrationsDir = tempDir / "db" / "migration"
      os.makeDir.all(migrationsDir)

      val v1Migration = migrationsDir / "V1__initial_schema.sql"
      os.write(v1Migration,
        """CREATE TABLE Person (
          |  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          |  name VARCHAR(255)
          |);
          |""".stripMargin)

      // Create H2 database and run Flyway V1
      dbUrl = s"jdbc:h2:${tempDir}/testdb;MODE=PostgreSQL"
      Class.forName("org.h2.Driver")
      conn = DriverManager.getConnection(dbUrl, "sa", "")

      // Execute V1 migration with Flyway
      val flyway = Flyway.configure()
        .dataSource(dbUrl, "sa", "")
        .locations(s"filesystem:${migrationsDir}")
        .load()

      val v1Applied = flyway.migrate()
      assert(v1Applied.migrationsExecuted == 1)

      // Insert test data
      val stmt = conn.createStatement()
      stmt.execute("INSERT INTO Person (name) VALUES ('John Doe')")
      stmt.execute("INSERT INTO Person (name) VALUES ('Jane Smith')")

      // Verify initial data
      val rs1 = stmt.executeQuery("SELECT id, name FROM Person ORDER BY id")
      rs1.next()
      assert(rs1.getString("name") == "John Doe")
      rs1.next()
      assert(rs1.getString("name") == "Jane Smith")
      rs1.close()
      stmt.close()
    }

    "2. User modifies Foo.scala (ambiguous change: name -> fullName)" - {
      // Copy Foo.scala to step2 directory and modify it there
      domainDir = tempDir / "step2_modified"
      os.makeDir.all(domainDir)
      fooFile = domainDir / "Foo.scala"

      // User edits the file, changing "name" to "fullName"
      os.write(fooFile,
        """package sbtmolecule.migrate.integration.workflowTempFiles.step2_modified
          |
          |import molecule.DomainStructure
          |
          |trait Foo extends DomainStructure {
          |  trait Person {
          |    val fullName = oneString
          |  }
          |}
          |""".stripMargin)

      // Parse modified structure (simulates second sbt moleculeGen)
      val List(meta) = ParseAndGenerate(fooFile.toString).generators.map(_.metaDomain)
      modifiedMeta = meta
    }

    "3. Plugin detects ambiguous change and throws error" - {
      val exception = intercept[Exception] {
        MigrationDetector.annotateBefore(initialMeta, modifiedMeta)
      }

      assert(exception.getMessage.contains("Schema changes detected but explicit migration commands are missing"))
      assert(exception.getMessage.contains("Person.name"))
    }

    "4. Plugin generates Foo_migration.scala beside Foo.scala" - {
      // Create step4 directory
      domainDir = tempDir / "step4_migration_generated"
      os.makeDir.all(domainDir)

      // Copy the modified Foo.scala to step4 with updated package
      fooFile = domainDir / "Foo.scala"
      val fooContent = os.read(tempDir / "step2_modified" / "Foo.scala")
      os.write(fooFile, fooContent.replaceFirst(
        "package sbtmolecule.migrate.integration.workflowTempFiles.step2_modified",
        "package sbtmolecule.migrate.integration.workflowTempFiles.step4_migration_generated"
      ))

      val migrationMeta = MigrationFileGenerator.migrationMetaDomain(
        initialMeta,
        modifiedMeta,
        "Foo_migration"
      )

      val migrationSource = MigrationFileGenerator.migrationSource(
        migrationMeta,
        "Foo",
        initialMeta,
        modifiedMeta
      )

      // Plugin writes Foo_migration.scalaTemp (not .scala since it won't compile)
      fooMigrationFile = domainDir / "Foo_migration.scalaTemp"

      // Update package in generated source
      val migrationSourceWithPackage = migrationSource.replaceFirst(
        "package app.domain",
        "package sbtmolecule.migrate.integration.workflowTempFiles.step4_migration_generated"
      )
      os.write(fooMigrationFile, migrationSourceWithPackage)

      // Verify file was created
      assert(os.exists(fooMigrationFile))

      // Verify migration file has both options (forces compilation error)
      val content = os.read(fooMigrationFile)
      assert(content.contains("val name = oneString.remove // if removed"))
      assert(content.contains("val name = oneString.becomes() // if renamed: add new attribute like .becomes(otherAttr)"))
    }

    "5. User resolves ambiguity by editing Foo_migration.scala" - {
      // Create step5 directory
      domainDir = tempDir / "step5_migration_resolved"
      os.makeDir.all(domainDir)

      // Copy Foo.scala to step5 with updated package
      fooFile = domainDir / "Foo.scala"
      val fooContent = os.read(tempDir / "step4_migration_generated" / "Foo.scala")
      os.write(fooFile, fooContent.replaceFirst(
        "package sbtmolecule.migrate.integration.workflowTempFiles.step4_migration_generated",
        "package sbtmolecule.migrate.integration.workflowTempFiles.step5_migration_resolved"
      ))

      // User edits Foo_migration.scala to choose rename option (this one compiles)
      fooMigrationFile = domainDir / "Foo_migration.scala"
      os.write(fooMigrationFile,
        """package sbtmolecule.migrate.integration.workflowTempFiles.step5_migration_resolved
          |
          |import molecule.DomainStructure
          |
          |trait Foo_migration extends Foo with DomainStructure {
          |
          |  // Please choose intended migration commands:
          |  // (comment-out or delete unwanted option lines)
          |
          |  trait PersonMigrations extends Person {
          |    val name = oneString.becomes(fullName)
          |  }
          |}
          |""".stripMargin)

      // Parse resolved migration file (simulates third sbt moleculeGen)
      val List(meta) = ParseAndGenerate(fooMigrationFile.toString).generators.map(_.metaDomain)
      resolvedMigrationMeta = meta
    }

    "6. Plugin applies migration commands and generates SQL" - {
      // Create step6 directory with SQL migration
      val step6Dir = tempDir / "step6_sql_generated"
      os.makeDir.all(step6Dir)

      // Apply migration commands to initial structure
      val initialWithMigrations = applyMigrationCommands(initialMeta, resolvedMigrationMeta)

      // Annotate with migration commands (should succeed now)
      annotatedBefore = MigrationDetector.annotateBefore(initialWithMigrations, modifiedMeta)

      // Generate SQL migration
      val sqlStatements = MigrationDetector.generateSQL(annotatedBefore)

      // Write SQL to file for inspection
      os.write(step6Dir / "migration.sql", sqlStatements.mkString("\n"))

      assert(sqlStatements == List("ALTER TABLE Person RENAME COLUMN name TO fullName;"))
    }

    "7. Flyway executes migration" - {
      // Add V2 migration to existing migrations directory (which already has V1)
      val migrationsDir = tempDir / "db" / "migration"

      val sqlStatements = MigrationDetector.generateSQL(annotatedBefore)
      val v2Migration   = migrationsDir / "V2__rename_person_name_to_fullName.sql"
      os.write(v2Migration, sqlStatements.mkString("\n"))

      // Execute V2 migration with Flyway (V1 was already applied in step 1)
      val flyway = Flyway.configure()
        .dataSource(dbUrl, "sa", "")
        .locations(s"filesystem:${migrationsDir}")
        .load()

      val migrationsApplied = flyway.migrate()
      assert(migrationsApplied.migrationsExecuted == 1) // Only V2 should be applied now
    }

    "8. Verify data persisted with new schema" - {
      val stmt = conn.createStatement()

      // Verify data exists with new column name
      val rs2 = stmt.executeQuery("SELECT id, fullName FROM Person ORDER BY id")
      rs2.next()
      assert(rs2.getString("fullName") == "John Doe") // Same data, new column name
      rs2.next()
      assert(rs2.getString("fullName") == "Jane Smith")
      rs2.close()

      // Verify old column name no longer exists
      val exception = intercept[Exception] {
        stmt.executeQuery("SELECT name FROM Person")
      }
      assert(exception.getMessage.toLowerCase.contains("name") ||
        exception.getMessage.toLowerCase.contains("column"))

      stmt.close()
    }

    "9. Cleanup" - {
      conn.close()
      // Clean up temporary test files
      if (os.exists(tempDir)) os.remove.all(tempDir)
    }
  }
}
